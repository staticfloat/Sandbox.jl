var documenterSearchIndex = {"docs":
[{"location":"#Sandbox.jl-Documentation","page":"Sandbox.jl Documentation","title":"Sandbox.jl Documentation","text":"","category":"section"},{"location":"","page":"Sandbox.jl Documentation","title":"Sandbox.jl Documentation","text":"Sandbox.jl provides basic containerization tools for running Linux guests on a variety of platforms.","category":"page"},{"location":"#Index","page":"Sandbox.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Sandbox.jl Documentation","title":"Sandbox.jl Documentation","text":"","category":"page"},{"location":"#Types","page":"Sandbox.jl Documentation","title":"Types","text":"","category":"section"},{"location":"","page":"Sandbox.jl Documentation","title":"Sandbox.jl Documentation","text":"Modules = [Sandbox]\nOrder = [:type]","category":"page"},{"location":"#Sandbox.BinFmtRegistration","page":"Sandbox.jl Documentation","title":"Sandbox.BinFmtRegistration","text":"BinFmtRegistration\n\nProvides a structured view of a binfmt_misc interpreter registration.  Note that only \"magic\" matching rules are allowed, we do not support \"extension\" matching rules.\n\n\n\n\n\n","category":"type"},{"location":"#Sandbox.BinFmtRegistration-Tuple{String}","page":"Sandbox.jl Documentation","title":"Sandbox.BinFmtRegistration","text":"BinFmtRegistration(file::String)\n\nReads a binfmt_misc registration in from disk, if it cannot be parsed (because it is malformed, or uses unsupported features) it an ArgumentError will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.SandboxConfig","page":"Sandbox.jl Documentation","title":"Sandbox.SandboxConfig","text":"SandboxConfig(read_only_maps, read_write_maps, env)\n\nSandbox executors require a configuration to set up the environment properly.\n\nread_only_maps: Directories that are mapped into the sandbox as read-only mappings.\nSpecified as pairs, e.g. sandbox_path => host_path.  All paths must be absolute.\nMust always include a mapping for root, e.g. \"/\" => rootfs_path.\nread_write_maps: Directories that are mapped into the sandbox as read-write mappings.\nSpecified as pairs, e.g. sandbox_path => host_path.  All paths must be absolute.\nNote that some executors may not show perfect live updates; consistency is guaranteed only after execution is finished.\nenv: Dictionary mapping of environment variables that should be set within the sandbox.\nentrypoint: Executable that gets passed the actual command being run.\nThis is a path within the sandbox, and must be absolute.\nDefaults to nothing, which causes the command to be executed directly.\npwd: Set the working directory of the command that will be run.\nThis is a path within the sandbox, and must be absolute.\npersist: Tell the executor object to persist changes made to the rootfs.\nThis is a boolean value, it is up to interpretation by the executor.\nPersistence is a property of an individual executor and changes live only as long as the executor object itself.\nYou cannot transfer persistent changes from one executor to another.\nmultiarch: Request multiarch executable support\nThis is an array of Platform objects\nSandbox will ensure that interpreters (such as qemu-*-static binaries) are available for each platform.\nRequesting multiarch support for a platform that we don't support results in an ArgumentError.\nuid and gid: Numeric user and group identifiers to spawn the sandboxed process as.\nBy default, these are both 0, signifying root inside the sandbox.\nstdin, stdout, stderr: input/output streams for the sandboxed process.\nCan be any kind of IO, TTY, devnull, etc...\nhostname: Set the hostname within the sandbox, defaults to the current hostname\nverbose: Set whether the sandbox construction process should be more or less verbose.\n\n\n\n\n\n","category":"type"},{"location":"#Sandbox.SandboxExecutor","page":"Sandbox.jl Documentation","title":"Sandbox.SandboxExecutor","text":"SandboxExecutor\n\nThis represents the base type for all execution backends within this package. Valid concrete subtypes must implement at least the following methods:\n\nT(): no-argument constructor to ready an execution engine with all defaults.\nexecutor_available(::DataType{T}): Checks whether executor type T is available on this system.  For example, UserNamespacesExecutors are only available on Linux, and even then only on certain kernels.  Availablility checks may run a program to determine whether that executor is actually available.\nbuild_executor_command(exe::T, config::SandboxConfig, cmd::Cmd): Builds the Cmd object that, when run, executes the user's desired command within the given sandbox.  The config object contains all necessary metadata such as shard mappings, environment variables, stdin/stdout/stderr redirection, etc...\ncleanup(exe::T): Cleans up any persistent data storage that this executor may have built up over the course of its execution.\n\nNote that while you can manually construct and cleanup an executor, it is recommended that users instead make use of the with_executor() convenience function:\n\nwith_executor(UnprivilegedUserNamespacesExecutor) do exe\n    run(exe, config, ...)\nend\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"Sandbox.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"Sandbox.jl Documentation","title":"Sandbox.jl Documentation","text":"Modules = [Sandbox]\nOrder = [:function]","category":"page"},{"location":"#Sandbox.build_docker_image-Tuple{Dict, Int32, Int32}","page":"Sandbox.jl Documentation","title":"Sandbox.build_docker_image","text":"build_docker_image(root_path::String)\n\nDocker doesn't like volume mounts within volume mounts, like we do with sandbox. So we do things \"the docker way\", where we construct a rootfs docker image, then mount things on top of that, with no recursive mounting.  We cut down on unnecessary work somewhat by quick-scanning the directory for changes and only rebuilding if changes are detected.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.check_binfmt_misc_loaded-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.check_binfmt_misc_loaded","text":"check_binfmt_misc_loaded()\n\nCheck that the binfmt_misc kernel module is loaded and enabled.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.default_persist_root_dirs-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.default_persist_root_dirs","text":"default_persist_root_dirs()\n\nReturns the default list of directories that should be attempted to be used as persistence storage.  Influenced by the SANDBOX_PERSISTENCE_DIR environment variable, as well as the persist_dir preference.  The last place searched by default is the persist_dirs scratch space.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.export_docker_image","page":"Sandbox.jl Documentation","title":"Sandbox.export_docker_image","text":"export_docker_image(image::String,\n                    output_dir::String = <default scratch location>;\n                    verbose::Bool = false,\n                    force::Bool = false)\n\nExports the given docker image name to the requested output directory.  Useful for pulling down a known good rootfs image from Docker Hub, for future use by Sandbox executors.  If force is set to true, will overwrite a pre-existing directory, otherwise will silently return.\n\n\n\n\n\n","category":"function"},{"location":"#Sandbox.get_kernel_version-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.get_kernel_version","text":"get_kernel_version(;verbose::Bool = false)\n\nUse uname() to get the kernel version and parse it out as a VersionNumber, returning nothing if parsing fails or this is not Linux.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.get_loaded_modules-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.get_loaded_modules","text":"get_loaded_modules()\n\nReturns a list of modules currently loaded by the system.  On non-Linux platforms, returns an empty list.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.getgid-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.getgid","text":"getgid()\n\nWrapper around libc's getgid() function\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.getuid-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.getuid","text":"getuid()\n\nWrapper around libc's getuid() function\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.is_ecryptfs-Tuple{AbstractString}","page":"Sandbox.jl Documentation","title":"Sandbox.is_ecryptfs","text":"is_ecryptfs(path::AbstractString; verbose::Bool=false)\n\nChecks to see if the given path (or any parent directory) is placed upon an ecryptfs mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603\n\nThis method returns whether it is encrypted or not, and what mountpoint it used to make that decision.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.load_env_pref-Tuple{AbstractString, AbstractString, Union{Nothing, AbstractString}}","page":"Sandbox.jl Documentation","title":"Sandbox.load_env_pref","text":"load_env_pref(env_var, prefs_name, default)\n\nMany pieces of Sandbox.jl functionality can be controlled either through environment variables or preferences.  This utility function makes it easy to check first the environment, then preferences, finally falling back to the default.  Additionally, it memoizes the result in a caching dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.max_directory_ctime-Tuple{String}","page":"Sandbox.jl Documentation","title":"Sandbox.max_directory_ctime","text":"max_directory_ctime(prefix::String)\n\nTakes the stat() of all files in a directory root, keeping the maximum ctime, recursively.  Comparing just this value allows for quick directory change detection.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.pull_docker_image","page":"Sandbox.jl Documentation","title":"Sandbox.pull_docker_image","text":"pull_docker_image(image::String,\n                  output_dir::String = <default scratch location>;\n                  platform::String = \"\",\n                  verbose::Bool = false,\n                  force::Bool = false)\n\nPulls and saves the given docker image name to the requested output directory. Useful for pulling down a known good rootfs image from Docker Hub, for future use by Sandbox executors.  If force is set to true, will overwrite a pre-existing directory, otherwise will silently return.  Optionally specify the platform of the image with platform.\n\n\n\n\n\n","category":"function"},{"location":"#Sandbox.read_binfmt_misc_registrations-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.read_binfmt_misc_registrations","text":"read_binfmt_misc_registrations()\n\nReturn a list of BinFmtRegistration objects, one per readable registration, as found sitting in /proc/sys/fs/binfmt_misc/*.  Registrations that cannot be parsed are silently ignored.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.realpath_stem-Tuple{AbstractString}","page":"Sandbox.jl Documentation","title":"Sandbox.realpath_stem","text":"realpath_stem(path::AbstractString)\n\nGiven a path, return the realpath of it.  If it does not exist, try to resolve the realpath of its containing directory, then append the tail portion onto the end of that resolved stem.  This iterates until we find a stem that can be resolved.\n\nThis allows for resolving directory symlinks halfway through a path, while not requiring that the final path leaf exist at the time of calling realpath_stem().  Of course, if the final path leaf is itself a symlink, this will not work correctly, so this should be considered a \"best effort\" function.\n\nInternally, we use this to attempt to discover the actual mountpoint a mapping is or will be stored on.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.register_requested_formats!-Tuple{Vector{Sandbox.BinFmtRegistration}}","page":"Sandbox.jl Documentation","title":"Sandbox.register_requested_formats!","text":"register_requested_formats(formats::Vector{BinFmtRegistration})\n\nGiven the list of binfmt_misc formats, check the currently-registered formats through read_binfmt_misc_registrations(), check to see if any in formats are not yet registered, and if they are not, call write_binfmt_misc_registration!() to register it with an artifact-sourced qemu-*-static binary.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.register_string-Tuple{Sandbox.BinFmtRegistration}","page":"Sandbox.jl Documentation","title":"Sandbox.register_string","text":"register_string(reg::BinFmtRegistration)\n\nConstructs the string used to register a binfmt_misc registration with the register file endpoint within /proc/sys/fs/binfmt_misc/register.  To actually register the interpreter, use write_binfmt_misc_registration().\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.uname-Tuple{}","page":"Sandbox.jl Documentation","title":"Sandbox.uname","text":"uname()\n\nOn Linux systems, return the strings returned by the uname() function in libc.\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.with_executor-Union{Tuple{T}, Tuple{F}, Tuple{F, Type{T}}} where {F<:Function, T<:SandboxExecutor}","page":"Sandbox.jl Documentation","title":"Sandbox.with_executor","text":"with_executor(f::Function, ::Type{<:SandboxExecutor} = preferred_executor(); kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"#Sandbox.write_binfmt_misc_registration!-Tuple{Sandbox.BinFmtRegistration}","page":"Sandbox.jl Documentation","title":"Sandbox.write_binfmt_misc_registration!","text":"write_binfmt_misc_registration(reg::BinFmtRegistration)\n\nWrite a binfmt_misc registration out to the kernel's register file endpoint. Requires sudo privileges.\n\n\n\n\n\n","category":"method"}]
}
